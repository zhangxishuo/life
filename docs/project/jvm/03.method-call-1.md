# JVM 如何执行方法调用(一)

有如下两个`Java`方法：

```java
void invoke(Object obj, Object... args) {
}
void invoke(String s, Object obj, Object... args) {
}
```

当执行`invoke(null, 1)`时，这个`invoke`调用有二义性。然而，`Java`编译器直接将方法调用识别为调用第二个方法，这究竟是为什么呢？

## 重载与重写

如果在同一个类中定义名字相同的方法，那么它们的参数列表必须不同。这称为方法重载。除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。

重载的方法在编译过程中即可完成识别。具体到每一个方法调用，`Java`编译器会根据所传入参数的声明类型来选取重载方法。

1. 在不考虑对基本类型自动装拆箱，以及可变长参数的情况下选取重载方法；
2. 如果在第`1`个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第`2`个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

如果`Java`编译器在同一个阶段中找到了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。

在开头的例子中，当传入`null`时，它既可以匹配第一个方法中声明为`Object`的形式参数，也可以匹配第二个方法中声明为`String`的形式参数。由于`String`是`Object`的子类，因此`Java`编译器会认为第二个方法更为贴切。

## 静态绑定和动态绑定

`Java`虚拟机识别方法的关键在于类名、方法名以及方法描述符`method descriptor`。方法描述符，是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么`Java`虚拟机会在类的验证阶段报错。

`Java`虚拟机与`Java`语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，由于字节码所附带的方法描述符包含了返回类型，因此`Java`虚拟机能够准确地识别目标方法。

因为某个类中的重载方法可能被它的子类所重写，因此`Java`编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。

`Java`虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

`Java`字节码中与调用相关的指令共有五种：

1. `invokestatic`：用于调用静态方法。
2. `invokespecial`：用于调用私有实例方法、构造器，以及使用`super`关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. `invokevirtual`：用于调用非私有实例方法。
4. `invokeinterface`：用于调用接口方法。
5. `invokedynamic`：用于调用动态方法。

## 调用指令的符号引用

在编译过程中，我们并不知道目标方法的具体内存地址。`Java`编译器会暂时用符号引用来表示该目标方法。符号引用存储在`class`文件的常量池之中。根据目标方法是否为接口方法，这些引用可分为接口符号引用和非接口符号引用。

在执行使用了符号引用的字节码前，`Java`虚拟机需要解析这些符号引用，并替换为实际引用。

对于非接口符号引用，假定该符号引用所指向的类为`C`，则`Java`虚拟机会按照如下步骤进行查找：

1. 在`C`中查找符合名字及描述符的方法。
2. 如果没有找到，在`C`的父类中继续搜索，直至`Object`类。
3. 如果没有找到，在`C`所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足`C`与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

对于接口符号引用，假定该符号引用所指向的接口为`I`，则`Java`虚拟机会按照如下步骤进行查找：

1. 在`I`中查找符合名字及描述符的方法。
2. 如果没有找到，在`Object`类中的公有实例方法中搜索。
3. 如果没有找到，则在`I`的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤`3`的要求一致。

经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。