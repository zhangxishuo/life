(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{418:function(t,a,s){t.exports=s.p+"assets/img/01.3102dff3.jpg"},419:function(t,a,s){t.exports=s.p+"assets/img/02.861f4730.jpg"},420:function(t,a,s){t.exports=s.p+"assets/img/03.fdf3da5d.jpg"},421:function(t,a,s){t.exports=s.p+"assets/img/04.63161034.jpg"},422:function(t,a,s){t.exports=s.p+"assets/img/05.c7dc8d39.jpg"},423:function(t,a,s){t.exports=s.p+"assets/img/06.6c6ecc33.jpg"},424:function(t,a,s){t.exports=s.p+"assets/img/07.412af530.jpg"},425:function(t,a,s){t.exports=s.p+"assets/img/08.5ae146b8.jpg"},461:function(t,a,s){"use strict";s.r(a);var e=s(62),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"语法分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法分析"}},[t._v("#")]),t._v(" 语法分析")]),t._v(" "),e("p",[t._v("语法分析的任务，就是将词法分析出的"),e("code",[t._v("Token")]),t._v("串，转换成"),e("strong",[t._v("抽象语法树")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"上下文无关文法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上下文无关文法"}},[t._v("#")]),t._v(" 上下文无关文法")]),t._v(" "),e("p",[t._v("在词法分析中，我们使用正规文法来表达词法规则；在语法分析中，需要使用"),e("strong",[t._v("上下文无关文法")]),t._v("来表达语法规则。")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("ADD -> ADD + MUL | MUL\nMUL -> MUL * pri | pri\n")])])]),e("p",[t._v("在语法规则里，箭头"),e("code",[t._v("->")]),t._v("左边的叫做非终结符。非终结符可以按照右边的正则表达式来逐步展开，直到最后都变成标识符、字面量、运算符这\n些不可再展开的符号，也就是终结符。终结符其实也是词法分析过程中形成的"),e("code",[t._v("Token")]),t._v("。")]),t._v(" "),e("p",[t._v("接下来，我们就要依据语法规则，编写语法分析程序，把"),e("code",[t._v("Token")]),t._v("串转化成"),e("code",[t._v("AST")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("h2",{attrs:{id:"递归下降算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归下降算法"}},[t._v("#")]),t._v(" 递归下降算法")]),t._v(" "),e("p",[t._v("递归下降算法的基本思路就是按照语法规则去匹配"),e("code",[t._v("Token")]),t._v("串。")]),t._v(" "),e("p",[t._v("变量声明的语法规则如下：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("varDecl -> types Id varInitializer ';'\nvarInitializer -> '=' exp | ε\nexp -> add\nadd -> add + mul | mul\nmul -> mul * pri | pri\npri -> IntLiteral | Id | ( exp )\n")])])]),e("p",[t._v("基于该规则解析的算法如下：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("匹配一个数据类型(types)\n匹配一个标识符(Id)，作为变量名称\n匹配初始化部分(varInitializer)，而这会导致下降一层，使用一个新的语法规则：\n    匹配一个等号\n    匹配一个表达式(在这个步骤会导致多层下降：exp->add->mul->pri->IntLiteral)\n    创建一个varInitializer对应的AST节点并返回\n如果没有成功地匹配初始化部分，则回溯，匹配e，也就是没有初始化部分。\n匹配一个分号\n创建一个varDecl对应的AST节点并返回\n")])])]),e("p",[t._v("用上述算法解析"),e("code",[t._v("int a = 2")]),t._v("，就会生成下面的"),e("code",[t._v("AST")]),t._v("：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(418),alt:"AST"}})]),t._v(" "),e("ul",[e("li",[t._v("对于一个非终结符，要从左到右依次匹配其产生式中的每个项，包括非终结符和终结符。")]),t._v(" "),e("li",[t._v("在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式。")]),t._v(" "),e("li",[t._v("如果一个语法规则有多个可选的产生式，那么只要有一个产生式匹配成功就行。如果一个产生式匹配不成功，那就回退回来，尝试另一个产生式。这种回退过程，叫做回溯"),e("code",[t._v("Backtracking")]),t._v("。")])]),t._v(" "),e("h3",{attrs:{id:"缺点一-左递归-left-recursion"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点一-左递归-left-recursion"}},[t._v("#")]),t._v(" 缺点一：左递归（Left Recursion）")]),t._v(" "),e("p",[t._v("针对文法"),e("code",[t._v("add -> add + mul")]),t._v("，产生的解析代码可能会像这样：")]),t._v(" "),e("div",{staticClass:"language-javascript extra-class"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("analysisAdd")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("analysisAdd")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("match")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'+'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("analysisMul")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("然后这个解析器在尝试去解析左递归文法时，会陷入一个无穷的递归。")]),t._v(" "),e("p",[e("strong",[t._v("引入add'，转换为右递归")])]),t._v(" "),e("p",[t._v("业界常用引入"),e("code",[t._v("add'")]),t._v("的方式，将左递归文法转换为右递归文法：")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("add -> mul add'\nadd' -> + mul add' | ε\n")])])]),e("p",[t._v("生成的"),e("code",[t._v("AST")]),t._v("如下：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(419),alt:"AST"}})]),t._v(" "),e("p",[t._v("针对右递归，生成的语法数会先计算"),e("code",[t._v("3+4")]),t._v("，这会导致加法的结合性问题。")]),t._v(" "),e("p",[e("strong",[t._v("用循环改写递归")])]),t._v(" "),e("p",[t._v("在代码实现中，可以用循环代替递归，这样可以在循环里根据运算符结合性要求，手动生成正确的"),e("code",[t._v("AST")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("add -> mul ( '+' mul ) * ;\n")])])]),e("p",[e("img",{attrs:{src:s(420),alt:"AST"}})]),t._v(" "),e("h3",{attrs:{id:"缺点二-回溯-backtracking"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点二-回溯-backtracking"}},[t._v("#")]),t._v(" 缺点二：回溯（Backtracking）")]),t._v(" "),e("p",[t._v("递归下降算法是不断尝试根据产生式生成语法树，再去匹配"),e("code",[t._v("Token")]),t._v("的。当匹配失败时，必须要“回溯”，这就可能导致浪费。")]),t._v(" "),e("p",[t._v("可以预读后续的一个"),e("code",[t._v("Token")]),t._v("，判断此应该选择哪个产生式。")]),t._v(" "),e("p",[t._v("经过仔细观察，你发现如果预读的"),e("code",[t._v("Token")]),t._v("是"),e("code",[t._v("Int")]),t._v("或"),e("code",[t._v("Long")]),t._v("，就选择变量声明语句；如果是"),e("code",[t._v("IntLiteral")]),t._v("、"),e("code",[t._v("Id")]),t._v("或左括号，就选择表达式语句；而如果是"),e("code",[t._v("Return")]),t._v("，则肯定是选择"),e("code",[t._v("return")]),t._v("语句。")]),t._v(" "),e("p",[t._v("需要使用"),e("code",[t._v("LL")]),t._v("算法，计算"),e("code",[t._v("Token")]),t._v("与产生式选择的关系。")]),t._v(" "),e("h2",{attrs:{id:"ll-算法-计算-first-和-follow-集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ll-算法-计算-first-和-follow-集合"}},[t._v("#")]),t._v(" LL 算法：计算 First 和 Follow 集合")]),t._v(" "),e("p",[e("strong",[t._v("First 集合是每个产生式开头可能会出现的 Token 的集合。")])]),t._v(" "),e("p",[e("img",{attrs:{src:s(421),alt:"First"}})]),t._v(" "),e("p",[e("strong",[t._v("对于某个非终结符后面可能跟着的 Token 的集合，我们叫做 Follow 集合。")])]),t._v(" "),e("p",[t._v("如果预读到的"),e("code",[t._v("Token")]),t._v("在"),e("code",[t._v("Follow")]),t._v("中，那么我们就可以判断当前正在匹配的这个非终结符，产生了"),e("code",[t._v("ε")]),t._v("。")]),t._v(" "),e("p",[t._v("这样在计算了"),e("code",[t._v("First")]),t._v("和"),e("code",[t._v("Follow")]),t._v("集合之后，你就可以通过预读一个"),e("code",[t._v("Token")]),t._v("，来完全确定采用哪个产生式。这种算法叫做"),e("strong",[t._v("LL(1) 算法")]),t._v("。")]),t._v(" "),e("h2",{attrs:{id:"lr-算法-移进和规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lr-算法-移进和规约"}},[t._v("#")]),t._v(" LR 算法：移进和规约")]),t._v(" "),e("p",[t._v("自顶向下算法，是从根节点逐层往下分解，形成最后的"),e("code",[t._v("AST")]),t._v("；而"),e("code",[t._v("LR")]),t._v("算法的原理，则是从底下先拼凑出"),e("code",[t._v("AST")]),t._v("的一些局部拼图，并逐步组装成一棵完整的"),e("code",[t._v("AST")]),t._v("。")]),t._v(" "),e("div",{staticClass:"language-text extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("start -> add\nadd -> add + mul | mul\nmul -> mul * pri | pri\npri -> Int | ( add )\n")])])]),e("p",[t._v("如果解析"),e("code",[t._v("2 + 3 * 5")]),t._v("，最终会形成下面的"),e("code",[t._v("AST")]),t._v("：")]),t._v(" "),e("p",[e("img",{attrs:{src:s(422),alt:"AST"}})]),t._v(" "),e("p",[t._v("在下图中，竖线的左边是栈，右边是预读到的一个"),e("code",[t._v("Token")]),t._v("。在做语法解析的过程中，竖线会不断地往右移动，"),e("code",[t._v("Token")]),t._v("入栈，这个过程叫做"),e("strong",[t._v("移进")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(423),alt:"移进"}})]),t._v(" "),e("p",[t._v("根据栈中的"),e("code",[t._v("Token")]),t._v("数据，通过产生式按推导过程将终结符反推回去，这个还原过程叫"),e("strong",[t._v("规约")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(424),alt:"规约"}})]),t._v(" "),e("p",[t._v("最后，整个"),e("code",[t._v("AST")]),t._v("构造完毕，而工作区里也就只剩了一个"),e("code",[t._v("Start")]),t._v("节点。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(425),alt:"AST"}})]),t._v(" "),e("p",[t._v("相对于"),e("code",[t._v("LL")]),t._v("算法，"),e("code",[t._v("LR")]),t._v("算法的优点是能够处理左递归文法。但缺点是不利于输出全面的编译错误信息。因为在没有解析完毕之前，算法并不知道最后的"),e("code",[t._v("AST")]),t._v("是什么样子，所以也不清楚当前的语法错误在整体"),e("code",[t._v("AST")]),t._v("中的位置。")])])}),[],!1,null,null,null);a.default=v.exports}}]);