(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{432:function(a,t,v){a.exports=v.p+"assets/img/00.d9ebaec4.jpg"},433:function(a,t,v){a.exports=v.p+"assets/img/01.74e6c6d6.jpg"},434:function(a,t,v){a.exports=v.p+"assets/img/02.168f1617.jpg"},464:function(a,t,v){"use strict";v.r(t);var _=v(62),e=Object(_.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"中间代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#中间代码"}},[a._v("#")]),a._v(" 中间代码")]),a._v(" "),_("p",[_("code",[a._v("IR")]),a._v("，也就是中间代码"),_("code",[a._v("Intermediate Representation")]),a._v("，有时也称"),_("code",[a._v("Intermediate Code")]),a._v("，它是编译器中很重要的一种数据结构。编译器在做完前端工作以后，首先就是生成"),_("code",[a._v("IR")]),a._v("，并在此基础上执行各种优化算法，最后再生成目标代码。")]),a._v(" "),_("h2",{attrs:{id:"ir-的用途和层次"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ir-的用途和层次"}},[a._v("#")]),a._v(" IR 的用途和层次")]),a._v(" "),_("p",[a._v("设计"),_("code",[a._v("IR")]),a._v("的用途：")]),a._v(" "),_("ul",[_("li",[a._v("分析和变换")]),a._v(" "),_("li",[a._v("直接解释执行")])]),a._v(" "),_("p",[a._v("编译器中，基于"),_("code",[a._v("IR")]),a._v("的分析和处理工作，一开始可以基于一些抽象层次比较高的语义，这时所需要的"),_("code",[a._v("IR")]),a._v("更接近源代码。而在后面，则会使用低层次的、更加接近目标代码的语义。")]),a._v(" "),_("p",[a._v("基于这种从高到低的抽象层次，"),_("code",[a._v("IR")]),a._v("可以归结为"),_("code",[a._v("HIR")]),a._v("、"),_("code",[a._v("MIR")]),a._v("和"),_("code",[a._v("LIR")]),a._v("三类。")]),a._v(" "),_("h3",{attrs:{id:"hir-基于源语言做一些分析和变换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hir-基于源语言做一些分析和变换"}},[a._v("#")]),a._v(" HIR：基于源语言做一些分析和变换")]),a._v(" "),_("p",[_("code",[a._v("High IR")]),a._v("，能够准确表达源语言的语义。")]),a._v(" "),_("p",[_("code",[a._v("AST")]),a._v("和符号表也可以准确表达源语言的语义，"),_("code",[a._v("AST")]),a._v("也可以算作一种"),_("code",[a._v("IR")]),a._v("。")]),a._v(" "),_("p",[a._v("基于"),_("code",[a._v("HIR")]),a._v("，可以做一些高层次的代码优化，比如常数折叠、内联等。在"),_("code",[a._v("Java")]),a._v("和"),_("code",[a._v("Go")]),a._v("的编译器中，你可以看到不少基于"),_("code",[a._v("AST")]),a._v("做的优化工作。")]),a._v(" "),_("h3",{attrs:{id:"mir-独立于源语言和-cpu-架构做分析和优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mir-独立于源语言和-cpu-架构做分析和优化"}},[a._v("#")]),a._v(" MIR：独立于源语言和 CPU 架构做分析和优化")]),a._v(" "),_("p",[a._v("大量的优化算法是可以通用的，没有必要依赖源语言的语法和语义，也没有必要依赖具体的"),_("code",[a._v("CPU")]),a._v("架构。")]),a._v(" "),_("p",[a._v("这些优化包括部分算术优化、常量和变量传播、死代码删除等。实现这类分析和优化功能的"),_("code",[a._v("IR")]),a._v("称为"),_("code",[a._v("Middle IR")]),a._v("。")]),a._v(" "),_("p",[a._v("因为"),_("code",[a._v("MIR")]),a._v("跟源代码和目标代码都无关，所以在讲解优化算法时，通常是基于"),_("code",[a._v("MIR")]),a._v("，如三地址代码"),_("code",[a._v("Three Address Code，TAC")]),a._v("。")]),a._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" b "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        b "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v("\n        b "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" b"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("p",[a._v("以上代码对应的"),_("code",[a._v("TAC")]),a._v("是：")]),a._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("BB1:\n    b := 0\n    if a > 10 goto BB3\nBB2:\n    b := 10\n    goto BB4\nBB3:\n    b := a\nBB4:\n    return b\n")])])]),_("p",[_("code",[a._v("TAC")]),a._v("用"),_("code",[a._v("goto")]),a._v("语句取代了"),_("code",[a._v("if")]),a._v("语句、循环语句这种比较高级的语句，当然也不会有类、继承这些高层的语言结构。但是，它又没有涉及数据如何在内存读写等细节，书写格式也不像汇编代码，与具体的目标代码也是独立的。")]),a._v(" "),_("h3",{attrs:{id:"lir-依赖于-cpu-架构做优化和代码生成"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lir-依赖于-cpu-架构做优化和代码生成"}},[a._v("#")]),a._v(" LIR：依赖于 CPU 架构做优化和代码生成")]),a._v(" "),_("p",[_("code",[a._v("Low IR")]),a._v("，其指令通常可以与机器指令一一对应，比较容易翻译成机器指令或汇编代码。"),_("code",[a._v("LIR")]),a._v("体现了"),_("code",[a._v("CPU")]),a._v("架构的底层特征，因此可以做一些"),_("code",[a._v("CPU")]),a._v("架构相关的优化。")]),a._v(" "),_("p",[_("img",{attrs:{src:v(432),alt:"LIR"}})]),a._v(" "),_("p",[a._v("这是"),_("code",[a._v("Java")]),a._v("的"),_("code",[a._v("JIT")]),a._v("编译器输出的"),_("code",[a._v("LIR")]),a._v("信息，里面的指令名称已经跟汇编代码很像了，并且会直接使用"),_("code",[a._v("AMD64")]),a._v("架构的寄存器名称。")]),a._v(" "),_("h3",{attrs:{id:"p-code-用于解释执行的-ir"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#p-code-用于解释执行的-ir"}},[a._v("#")]),a._v(" P-code：用于解释执行的 IR")]),a._v(" "),_("p",[_("code",[a._v("Portable Code")]),a._v("，与具体机器无关，因此可以很容易地运行在多种电脑上。这类"),_("code",[a._v("IR")]),a._v("对编译器来说，就是做编译的目标代码。"),_("code",[a._v("Java")]),a._v("的字节码就是"),_("code",[a._v("P-code")]),a._v("。除此之外，"),_("code",[a._v("Python")]),a._v("、"),_("code",[a._v("Erlang")]),a._v("也有自己的字节码，"),_("code",[a._v(".NET")]),a._v("平台、"),_("code",[a._v("Visual Basic")]),a._v("程序也不例外。")]),a._v(" "),_("p",[a._v("其实，完全可以基于"),_("code",[a._v("AST")]),a._v("实现一个全功能的解释器，只不过性能会差一些。对于专门用来解释执行的"),_("code",[a._v("IR")]),a._v("，通常会有一些特别的设计，跟虚拟机配合来尽量提升运行速度。")]),a._v(" "),_("p",[_("code",[a._v("P-code")]),a._v("也可能被进一步编译，形成可以直接执行的机器码。"),_("code",[a._v("Java")]),a._v("的字节码就是这样的例子。")]),a._v(" "),_("h2",{attrs:{id:"ir-的数据结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ir-的数据结构"}},[a._v("#")]),a._v(" IR 的数据结构")]),a._v(" "),_("p",[_("code",[a._v("IR")]),a._v("并不像源代码和汇编代码那样有特定的书写格式，只是编译过程中的一个数据结构而已。")]),a._v(" "),_("p",[a._v("在实际的实现中，有线性结构、树结构、有向无环图"),_("code",[a._v("DAG")]),a._v("、程序依赖图"),_("code",[a._v("PDG")]),a._v("等多种格式。要根据具体要处理的工作的特点，来选择合适的数据结构。")]),a._v(" "),_("h3",{attrs:{id:"第一种-类似-tac-的线性结构-linear-form"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一种-类似-tac-的线性结构-linear-form"}},[a._v("#")]),a._v(" 第一种：类似 TAC 的线性结构（Linear Form）")]),a._v(" "),_("p",[a._v("你可以把代码表示成一行行的指令或语句，用数组或者列表保存就行了。其中的符号，需要引用符号表，来提供类型等信息。")]),a._v(" "),_("p",[a._v("这种线性结构有时候也被称作"),_("code",[a._v("goto")]),a._v("格式。因为高级语言里的条件语句、循环语句，要变成用"),_("code",[a._v("goto")]),a._v("语句跳转的方式。")]),a._v(" "),_("h3",{attrs:{id:"第二种-树结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二种-树结构"}},[a._v("#")]),a._v(" 第二种：树结构")]),a._v(" "),_("p",[a._v("树结构可以用作"),_("code",[a._v("IR")]),a._v("，"),_("code",[a._v("AST")]),a._v("就是一种树结构。树结构的缺点是，可能有冗余的子树。")]),a._v(" "),_("p",[_("img",{attrs:{src:v(433),alt:"树结构"}})]),a._v(" "),_("p",[a._v("语句"),_("code",[a._v("a = 5; b = (2 + a) + a * 3;")]),a._v("形成的"),_("code",[a._v("AST")]),a._v("，如果基于这个树结构生成代码，可能会做两次从内存中读取"),_("code",[a._v("a")]),a._v("的值的操作，并存到两个临时变量中。")]),a._v(" "),_("h3",{attrs:{id:"第三种-有向无环图-directed-acyclic-graph-dag"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三种-有向无环图-directed-acyclic-graph-dag"}},[a._v("#")]),a._v(" 第三种：有向无环图（Directed Acyclic Graph，DAG）")]),a._v(" "),_("p",[_("code",[a._v("DAG")]),a._v("结构，是在树结构的基础上，消除了冗余的子树。转化成"),_("code",[a._v("DAG")]),a._v("以后，对"),_("code",[a._v("a")]),a._v("的内存访问只做一次就行了。")]),a._v(" "),_("p",[_("img",{attrs:{src:v(434),alt:"DAG"}})]),a._v(" "),_("h3",{attrs:{id:"第四种-程序依赖图-program-dependence-graph-pdg"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四种-程序依赖图-program-dependence-graph-pdg"}},[a._v("#")]),a._v(" 第四种：程序依赖图（Program Dependence Graph，PDG）")]),a._v(" "),_("p",[a._v("程序依赖图，是显式地把程序中的数据依赖和控制依赖表示出来，形成一个图状的数据结构。基于这个数据结构，我们再做一些优化算法的时候，会更容易实现。")]),a._v(" "),_("p",[a._v("所以现在，有很多编译器在运行优化算法的时候，都基于类似"),_("code",[a._v("PDG")]),a._v("的数据结构，比如我在课程后面会分析的"),_("code",[a._v("Java")]),a._v("的"),_("code",[a._v("JIT")]),a._v("编译器和"),_("code",[a._v("JavaScript")]),a._v("的编译器。")]),a._v(" "),_("h2",{attrs:{id:"ssa-格式的-ir"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ssa-格式的-ir"}},[a._v("#")]),a._v(" SSA 格式的 IR")]),a._v(" "),_("p",[_("code",[a._v("SSA")]),a._v("是"),_("code",[a._v("Static Single Assignment")]),a._v("的缩写，也就是静态单赋值。这是"),_("code",[a._v("IR")]),a._v("的一种设计范式，它要求一个变量只能被赋值一次。")]),a._v(" "),_("p",[_("code",[a._v("y = x1 + x2 + x3 + x4")]),a._v("的普通"),_("code",[a._v("TAC")]),a._v("如下：")]),a._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("y := x1 + x2;\ny := y + x3;\ny := y + x4;\n")])])]),_("p",[a._v("其中，"),_("code",[a._v("y")]),a._v("被赋值了三次，改写成"),_("code",[a._v("SSA")]),a._v("的形式：")]),a._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("t1 := x1 + x2;\nt2 := t1 + x3;\ny  := t2 + x4;\n")])])]),_("p",[a._v("为什么要费力写成这种形式呢，还要为此多添加"),_("code",[a._v("t1")]),a._v("和"),_("code",[a._v("t2")]),a._v("两个临时变量？")]),a._v(" "),_("p",[a._v("原因是，使用"),_("code",[a._v("SSA")]),a._v("的形式，体现了精确的"),_("strong",[a._v("使用 - 定义")]),_("code",[a._v("Use-def")]),a._v("关系。并且由于变量的值定义出来以后就不再变化，使得基于"),_("code",[a._v("SSA")]),a._v("更容易运行一些优化算法。")]),a._v(" "),_("div",{staticClass:"language-c extra-class"},[_("pre",{pre:!0,attrs:{class:"language-c"}},[_("code",[_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[a._v("foo")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" b "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("a "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n        b "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v("\n        b "),_("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),_("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" b"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),_("p",[a._v("对于同样的示例代码，对应的"),_("code",[a._v("SSA")]),a._v("格式如下：")]),a._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[a._v("BB1:\n    b1 := 0\n    if a > 10 goto BB3\nBB2:\n    b2 := 10\n    goto BB4\nBB3:\n    b3 := a\nBB4:\n    b4 := phi(BB2, BB3, b2, b3)\n    return b4\n")])])]),_("p",[_("code",[a._v("phi")]),a._v("指令，会根据控制流的实际情况确定"),_("code",[a._v("b4")]),a._v("的值。如果"),_("code",[a._v("BB4")]),a._v("的前序节点是"),_("code",[a._v("BB2")]),a._v("，那么"),_("code",[a._v("b4")]),a._v("的取值是"),_("code",[a._v("b2")]),a._v("；而如果"),_("code",[a._v("BB4")]),a._v("的前序节点是"),_("code",[a._v("BB3")]),a._v("，那么"),_("code",[a._v("b4")]),a._v("的取值就是"),_("code",[a._v("b3")]),a._v("。")]),a._v(" "),_("p",[a._v("如果要满足"),_("code",[a._v("SSA")]),a._v("的要求，那么在遇到有程序分支的情况下，就必须引入"),_("code",[a._v("phi")]),a._v("指令。")]),a._v(" "),_("p",[_("strong",[a._v("由于 SSA 格式的优点，现代语言用于优化的 IR，很多都是基于 SSA 的了，包括我们本课程涉及的 Java 的 JIT 编译器、JavaScript 的 V8 编译器、Go 语言的 gc 编译器、Julia 编译器，以及 LLVM 工具等。")])])])}),[],!1,null,null,null);t.default=e.exports}}]);