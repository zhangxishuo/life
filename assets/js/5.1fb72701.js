(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{441:function(s,t,a){s.exports=a.p+"assets/img/00.e9b48480.jpg"},442:function(s,t,a){s.exports=a.p+"assets/img/01.8bdca3ce.jpg"},443:function(s,t,a){s.exports=a.p+"assets/img/02.f43e54b6.jpg"},444:function(s,t,a){s.exports=a.p+"assets/img/03.cccebba3.jpg"},445:function(s,t,a){s.exports=a.p+"assets/img/04.d4b9302c.jpg"},482:function(s,t,a){"use strict";a.r(t);var e=a(62),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"编译原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译原理"}},[s._v("#")]),s._v(" 编译原理")]),s._v(" "),e("p",[s._v("先看一个例子：")]),s._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[e("span",{pre:!0,attrs:{class:"token directive-hash"}},[s._v("#")]),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[s._v("include")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("<stdio.h>")])]),s._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v('"Hello World!\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[s._v("➜  "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" gcc -o main main.c\n➜  "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("test")]),s._v(" ./main\nHello World"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("!")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("从一段朴素的"),e("code",[s._v("printf")]),s._v("，到计算机打印出"),e("code",[s._v("Hello World!")]),s._v("，问题来了：计算机，是怎么理解人类的编程语言并正确执行的？")]),s._v(" "),e("h2",{attrs:{id:"何为编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何为编译"}},[s._v("#")]),s._v(" 何为编译")]),s._v(" "),e("p",[s._v("我们使用"),e("code",[s._v("Java")]),s._v("、"),e("code",[s._v("C++")]),s._v("等高级语言进行日常开发，而机器运行的是机器语言；"),e("strong",[s._v("从我们的源代码变成目标语言的过程，称为编译。")])]),s._v(" "),e("p",[s._v("如果源代码编译后要在操作系统运行，目标代码就是汇编代码；如果编译后在解释器中执行，目标代码是一种解释器可以理解的中间代码即可。")]),s._v(" "),e("p",[e("img",{attrs:{src:a(441),alt:"编译架构"}})]),s._v(" "),e("h2",{attrs:{id:"词法分析-lexical-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法分析-lexical-analysis"}},[s._v("#")]),s._v(" 词法分析（Lexical Analysis）")]),s._v(" "),e("p",[s._v("在编译之前，源代码只是一长串字符而已。所以，编译的第一步，就是要像读文章一样，先把里面的单词和标点符号识别出来。程序里面的单词叫做"),e("code",[s._v("Token")]),s._v("，它可以分成关键字、标识符、字面量、操作符号等多个种类。")]),s._v(" "),e("p",[e("strong",[s._v("把字符串转换为 Token 的过程，就叫做词法分析。")])]),s._v(" "),e("p",[e("img",{attrs:{src:a(442),alt:"词法分析"}})]),s._v(" "),e("h2",{attrs:{id:"语法分析-syntactic-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法分析-syntactic-analysis"}},[s._v("#")]),s._v(" 语法分析（Syntactic Analysis）")]),s._v(" "),e("p",[s._v("词法分析程序识别出"),e("code",[s._v("Token")]),s._v("后，我们需要让编译器"),e("strong",[s._v("像理解自然语言一样，理解它的语法结构")]),s._v("，称为"),e("strong",[s._v("语法分析")]),s._v("。")]),s._v(" "),e("p",[s._v("语法分析程序会把"),e("code",[s._v("Token")]),s._v("串，转换成一个"),e("strong",[s._v("体现语法规则的、树状的数据结构——抽象语法树")]),s._v("。")]),s._v(" "),e("p",[e("img",{attrs:{src:a(443),alt:"语法分析"}})]),s._v(" "),e("p",[s._v("这样的一棵"),e("code",[s._v("AST")]),s._v("反映了示例程序的语法结构。这棵抽象语法树的顶部就是一个函数节点，它包含了四个子节点，刚好反映了函数的语法。")]),s._v(" "),e("h2",{attrs:{id:"语义分析-semantic-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语义分析-semantic-analysis"}},[s._v("#")]),s._v(" 语义分析（Semantic Analysis）")]),s._v(" "),e("p",[e("strong",[s._v("语义分析程序会针对语法树进行上下文相关分析，生成带有语义信息的抽象语法树 Abstract Syntax Tree。")])]),s._v(" "),e("p",[s._v("语义理解：下图中的参与"),e("code",[s._v("add")]),s._v("运算的叶子节点"),e("code",[s._v("a")]),s._v("，是上文中已赋值的全局变量？还是参数中传入的引用？都需要程序结合上下文进行引用消解。")]),s._v(" "),e("p",[s._v("语义检查：语义分析过程进行变量的类型检查等。")]),s._v(" "),e("p",[e("img",{attrs:{src:a(444),alt:"语义分析"}})]),s._v(" "),e("h2",{attrs:{id:"中间代码-intermediate-representation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间代码-intermediate-representation"}},[s._v("#")]),s._v(" 中间代码（Intermediate Representation）")]),s._v(" "),e("p",[s._v("中间代码"),e("code",[s._v("IR")]),s._v("，是处于源代码和目标代码之间的一种表示形式。")]),s._v(" "),e("p",[e("code",[s._v("Python")]),s._v("和"),e("code",[s._v("Java")]),s._v("等解释型的语言，可以直接执行"),e("code",[s._v("IR")]),s._v("，编译器生成"),e("code",[s._v("IR")]),s._v("以后就完成任务了，没有必要生成最终的汇编代码。")]),s._v(" "),e("p",[s._v("另外，我们生成代码的时候，需要做大量的优化工作。如果基于汇编代码来做，那需要根据不同的"),e("code",[s._v("CPU")]),s._v("架构进行适配，而基于"),e("code",[s._v("IR")]),s._v("，可以用统一的算法来完成。")]),s._v(" "),e("h2",{attrs:{id:"优化-optimization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化-optimization"}},[s._v("#")]),s._v(" 优化（Optimization）")]),s._v(" "),e("p",[e("code",[s._v("Java")]),s._v("中通过公有方法实现对私有属性的访问，但在汇编代码中，函数调用会花费很大的开销。通过进行方法的"),e("strong",[s._v("内联")]),s._v("，将函数内的逻辑直接嵌入函数调用者的代码中，实现性能提升。")]),s._v(" "),e("p",[s._v("并且针对一些不是最优的代码，编译器进行纠正优化以提升性能。")]),s._v(" "),e("p",[e("img",{attrs:{src:a(445),alt:"优化"}})]),s._v(" "),e("p",[s._v("采用中间代码来编写优化算法的好处，可以把大部分的优化算法，写成与具体"),e("code",[s._v("CPU")]),s._v("架构无关的形式，从而大大降低编译器适配不同"),e("code",[s._v("CPU")]),s._v("的工作量。")]),s._v(" "),e("h2",{attrs:{id:"生成目标代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成目标代码"}},[s._v("#")]),s._v(" 生成目标代码")]),s._v(" "),e("p",[s._v("生成目标代码，即生成最终的汇编代码。")]),s._v(" "),e("ol",[e("li",[s._v("选择合适的指令，生成性能最高的代码。")]),s._v(" "),e("li",[s._v("优化寄存器的分配，让频繁访问的变量（比如循环变量）放到寄存器里，因为访问寄存器要比访问内存快"),e("code",[s._v("100")]),s._v("倍左右。")]),s._v(" "),e("li",[s._v("在不改变运行结果的情况下，对指令做重新排序，从而充分运用"),e("code",[s._v("CPU")]),s._v("内部的多个功能部件的并行计算能力。")])]),s._v(" "),e("p",[s._v("目标代码生成以后，整个编译过程就完成了。")])])}),[],!1,null,null,null);t.default=n.exports}}]);