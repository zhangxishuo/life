(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{436:function(t,s,a){t.exports=a.p+"assets/img/00.e9b48480.jpg"},437:function(t,s,a){t.exports=a.p+"assets/img/01.8bdca3ce.jpg"},438:function(t,s,a){t.exports=a.p+"assets/img/02.f43e54b6.jpg"},439:function(t,s,a){t.exports=a.p+"assets/img/03.cccebba3.jpg"},440:function(t,s,a){t.exports=a.p+"assets/img/04.d4b9302c.jpg"},467:function(t,s,a){"use strict";a.r(s);var e=a(62),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"编译原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译原理"}},[t._v("#")]),t._v(" 编译原理")]),t._v(" "),e("p",[t._v("先看一个例子：")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[e("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello World!\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("div",{staticClass:"language-shell extra-class"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[t._v("➜  "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("test")]),t._v(" gcc -o main main.c\n➜  "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("test")]),t._v(" ./main\nHello World"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("\n")])])]),e("p",[t._v("从一段朴素的"),e("code",[t._v("printf")]),t._v("，到计算机打印出"),e("code",[t._v("Hello World!")]),t._v("，问题来了：计算机，是怎么理解人类的编程语言并正确执行的？")]),t._v(" "),e("h2",{attrs:{id:"何为编译"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#何为编译"}},[t._v("#")]),t._v(" 何为编译")]),t._v(" "),e("p",[t._v("我们使用"),e("code",[t._v("Java")]),t._v("、"),e("code",[t._v("C++")]),t._v("等高级语言进行日常开发，而机器运行的是机器语言；"),e("strong",[t._v("从我们的源代码变成目标语言的过程，称为编译。")])]),t._v(" "),e("p",[t._v("如果源代码编译后要在操作系统运行，目标代码就是汇编代码；如果编译后在解释器中执行，目标代码是一种解释器可以理解的中间代码即可。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(436),alt:"编译架构"}})]),t._v(" "),e("h2",{attrs:{id:"词法分析-lexical-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法分析-lexical-analysis"}},[t._v("#")]),t._v(" 词法分析（Lexical Analysis）")]),t._v(" "),e("p",[t._v("在编译之前，源代码只是一长串字符而已。所以，编译的第一步，就是要像读文章一样，先把里面的单词和标点符号识别出来。程序里面的单词叫做"),e("code",[t._v("Token")]),t._v("，它可以分成关键字、标识符、字面量、操作符号等多个种类。")]),t._v(" "),e("p",[e("strong",[t._v("把字符串转换为 Token 的过程，就叫做词法分析。")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(437),alt:"词法分析"}})]),t._v(" "),e("h2",{attrs:{id:"语法分析-syntactic-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法分析-syntactic-analysis"}},[t._v("#")]),t._v(" 语法分析（Syntactic Analysis）")]),t._v(" "),e("p",[t._v("词法分析程序识别出"),e("code",[t._v("Token")]),t._v("后，我们需要让编译器"),e("strong",[t._v("像理解自然语言一样，理解它的语法结构")]),t._v("，称为"),e("strong",[t._v("语法分析")]),t._v("。")]),t._v(" "),e("p",[t._v("语法分析程序会把"),e("code",[t._v("Token")]),t._v("串，转换成一个"),e("strong",[t._v("体现语法规则的、树状的数据结构——抽象语法树")]),t._v("。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(438),alt:"语法分析"}})]),t._v(" "),e("p",[t._v("这样的一棵"),e("code",[t._v("AST")]),t._v("反映了示例程序的语法结构。这棵抽象语法树的顶部就是一个函数节点，它包含了四个子节点，刚好反映了函数的语法。")]),t._v(" "),e("h2",{attrs:{id:"语义分析-semantic-analysis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语义分析-semantic-analysis"}},[t._v("#")]),t._v(" 语义分析（Semantic Analysis）")]),t._v(" "),e("p",[e("strong",[t._v("语义分析程序会针对语法树进行上下文相关分析，生成带有语义信息的抽象语法树 Abstract Syntax Tree。")])]),t._v(" "),e("p",[t._v("语义理解：下图中的参与"),e("code",[t._v("add")]),t._v("运算的叶子节点"),e("code",[t._v("a")]),t._v("，是上文中已赋值的全局变量？还是参数中传入的引用？都需要程序结合上下文进行引用消解。")]),t._v(" "),e("p",[t._v("语义检查：语义分析过程进行变量的类型检查等。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(439),alt:"语义分析"}})]),t._v(" "),e("h2",{attrs:{id:"中间代码-intermediate-representation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#中间代码-intermediate-representation"}},[t._v("#")]),t._v(" 中间代码（Intermediate Representation）")]),t._v(" "),e("p",[t._v("中间代码"),e("code",[t._v("IR")]),t._v("，是处于源代码和目标代码之间的一种表示形式。")]),t._v(" "),e("p",[e("code",[t._v("Python")]),t._v("和"),e("code",[t._v("Java")]),t._v("等解释型的语言，可以直接执行"),e("code",[t._v("IR")]),t._v("，编译器生成"),e("code",[t._v("IR")]),t._v("以后就完成任务了，没有必要生成最终的汇编代码。")]),t._v(" "),e("p",[t._v("另外，我们生成代码的时候，需要做大量的优化工作。如果基于汇编代码来做，那需要根据不同的"),e("code",[t._v("CPU")]),t._v("架构进行适配，而基于"),e("code",[t._v("IR")]),t._v("，可以用统一的算法来完成。")]),t._v(" "),e("h2",{attrs:{id:"优化-optimization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化-optimization"}},[t._v("#")]),t._v(" 优化（Optimization）")]),t._v(" "),e("p",[e("code",[t._v("Java")]),t._v("中通过公有方法实现对私有属性的访问，但在汇编代码中，函数调用会花费很大的开销。通过进行方法的"),e("strong",[t._v("内联")]),t._v("，将函数内的逻辑直接嵌入函数调用者的代码中，实现性能提升。")]),t._v(" "),e("p",[t._v("并且针对一些不是最优的代码，编译器进行纠正优化以提升性能。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(440),alt:"优化"}})]),t._v(" "),e("p",[t._v("采用中间代码来编写优化算法的好处，可以把大部分的优化算法，写成与具体"),e("code",[t._v("CPU")]),t._v("架构无关的形式，从而大大降低编译器适配不同"),e("code",[t._v("CPU")]),t._v("的工作量。")]),t._v(" "),e("h2",{attrs:{id:"生成目标代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生成目标代码"}},[t._v("#")]),t._v(" 生成目标代码")]),t._v(" "),e("p",[t._v("生成目标代码，即生成最终的汇编代码。")]),t._v(" "),e("ol",[e("li",[t._v("选择合适的指令，生成性能最高的代码。")]),t._v(" "),e("li",[t._v("优化寄存器的分配，让频繁访问的变量（比如循环变量）放到寄存器里，因为访问寄存器要比访问内存快"),e("code",[t._v("100")]),t._v("倍左右。")]),t._v(" "),e("li",[t._v("在不改变运行结果的情况下，对指令做重新排序，从而充分运用"),e("code",[t._v("CPU")]),t._v("内部的多个功能部件的并行计算能力。")])]),t._v(" "),e("p",[t._v("目标代码生成以后，整个编译过程就完成了。")])])}),[],!1,null,null,null);s.default=v.exports}}]);