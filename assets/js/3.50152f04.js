(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{423:function(s,a,t){s.exports=t.p+"assets/img/01.3102dff3.jpg"},424:function(s,a,t){s.exports=t.p+"assets/img/02.861f4730.jpg"},425:function(s,a,t){s.exports=t.p+"assets/img/03.fdf3da5d.jpg"},426:function(s,a,t){s.exports=t.p+"assets/img/04.63161034.jpg"},427:function(s,a,t){s.exports=t.p+"assets/img/05.c7dc8d39.jpg"},428:function(s,a,t){s.exports=t.p+"assets/img/06.6c6ecc33.jpg"},429:function(s,a,t){s.exports=t.p+"assets/img/07.412af530.jpg"},430:function(s,a,t){s.exports=t.p+"assets/img/08.5ae146b8.jpg"},491:function(s,a,t){"use strict";t.r(a);var e=t(62),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"语法分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语法分析"}},[s._v("#")]),s._v(" 语法分析")]),s._v(" "),e("p",[s._v("语法分析的任务，就是将词法分析出的"),e("code",[s._v("Token")]),s._v("串，转换成"),e("strong",[s._v("抽象语法树")]),s._v("。")]),s._v(" "),e("h2",{attrs:{id:"上下文无关文法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#上下文无关文法"}},[s._v("#")]),s._v(" 上下文无关文法")]),s._v(" "),e("p",[s._v("在词法分析中，我们使用正规文法来表达词法规则；在语法分析中，需要使用"),e("strong",[s._v("上下文无关文法")]),s._v("来表达语法规则。")]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("ADD -> ADD + MUL | MUL\nMUL -> MUL * pri | pri\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("在语法规则里，箭头"),e("code",[s._v("->")]),s._v("左边的叫做非终结符。非终结符可以按照右边的正则表达式来逐步展开，直到最后都变成标识符、字面量、运算符这\n些不可再展开的符号，也就是终结符。终结符其实也是词法分析过程中形成的"),e("code",[s._v("Token")]),s._v("。")]),s._v(" "),e("p",[s._v("接下来，我们就要依据语法规则，编写语法分析程序，把"),e("code",[s._v("Token")]),s._v("串转化成"),e("code",[s._v("AST")]),s._v("。")]),s._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" b "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" a "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("h2",{attrs:{id:"递归下降算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#递归下降算法"}},[s._v("#")]),s._v(" 递归下降算法")]),s._v(" "),e("p",[s._v("递归下降算法的基本思路就是按照语法规则去匹配"),e("code",[s._v("Token")]),s._v("串。")]),s._v(" "),e("p",[s._v("变量声明的语法规则如下：")]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("varDecl -> types Id varInitializer ';'\nvarInitializer -> '=' exp | ε\nexp -> add\nadd -> add + mul | mul\nmul -> mul * pri | pri\npri -> IntLiteral | Id | ( exp )\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br")])]),e("p",[s._v("基于该规则解析的算法如下：")]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("匹配一个数据类型(types)\n匹配一个标识符(Id)，作为变量名称\n匹配初始化部分(varInitializer)，而这会导致下降一层，使用一个新的语法规则：\n    匹配一个等号\n    匹配一个表达式(在这个步骤会导致多层下降：exp->add->mul->pri->IntLiteral)\n    创建一个varInitializer对应的AST节点并返回\n如果没有成功地匹配初始化部分，则回溯，匹配e，也就是没有初始化部分。\n匹配一个分号\n创建一个varDecl对应的AST节点并返回\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br")])]),e("p",[s._v("用上述算法解析"),e("code",[s._v("int a = 2")]),s._v("，就会生成下面的"),e("code",[s._v("AST")]),s._v("：")]),s._v(" "),e("p",[e("img",{attrs:{src:t(423),alt:"AST"}})]),s._v(" "),e("ul",[e("li",[s._v("对于一个非终结符，要从左到右依次匹配其产生式中的每个项，包括非终结符和终结符。")]),s._v(" "),e("li",[s._v("在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式。")]),s._v(" "),e("li",[s._v("如果一个语法规则有多个可选的产生式，那么只要有一个产生式匹配成功就行。如果一个产生式匹配不成功，那就回退回来，尝试另一个产生式。这种回退过程，叫做回溯"),e("code",[s._v("Backtracking")]),s._v("。")])]),s._v(" "),e("h3",{attrs:{id:"缺点一-左递归-left-recursion"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点一-左递归-left-recursion"}},[s._v("#")]),s._v(" 缺点一：左递归（Left Recursion）")]),s._v(" "),e("p",[s._v("针对文法"),e("code",[s._v("add -> add + mul")]),s._v("，产生的解析代码可能会像这样：")]),s._v(" "),e("div",{staticClass:"language-javascript line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-javascript"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("analysisAdd")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("analysisAdd")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("match")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[s._v("'+'")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("analysisMul")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])]),e("p",[s._v("然后这个解析器在尝试去解析左递归文法时，会陷入一个无穷的递归。")]),s._v(" "),e("p",[e("strong",[s._v("引入add'，转换为右递归")])]),s._v(" "),e("p",[s._v("业界常用引入"),e("code",[s._v("add'")]),s._v("的方式，将左递归文法转换为右递归文法：")]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("add -> mul add'\nadd' -> + mul add' | ε\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("生成的"),e("code",[s._v("AST")]),s._v("如下：")]),s._v(" "),e("p",[e("img",{attrs:{src:t(424),alt:"AST"}})]),s._v(" "),e("p",[s._v("针对右递归，生成的语法数会先计算"),e("code",[s._v("3+4")]),s._v("，这会导致加法的结合性问题。")]),s._v(" "),e("p",[e("strong",[s._v("用循环改写递归")])]),s._v(" "),e("p",[s._v("在代码实现中，可以用循环代替递归，这样可以在循环里根据运算符结合性要求，手动生成正确的"),e("code",[s._v("AST")]),s._v("。")]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("add -> mul ( '+' mul ) * ;\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[e("img",{attrs:{src:t(425),alt:"AST"}})]),s._v(" "),e("h3",{attrs:{id:"缺点二-回溯-backtracking"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点二-回溯-backtracking"}},[s._v("#")]),s._v(" 缺点二：回溯（Backtracking）")]),s._v(" "),e("p",[s._v("递归下降算法是不断尝试根据产生式生成语法树，再去匹配"),e("code",[s._v("Token")]),s._v("的。当匹配失败时，必须要“回溯”，这就可能导致浪费。")]),s._v(" "),e("p",[s._v("可以预读后续的一个"),e("code",[s._v("Token")]),s._v("，判断此应该选择哪个产生式。")]),s._v(" "),e("p",[s._v("经过仔细观察，你发现如果预读的"),e("code",[s._v("Token")]),s._v("是"),e("code",[s._v("Int")]),s._v("或"),e("code",[s._v("Long")]),s._v("，就选择变量声明语句；如果是"),e("code",[s._v("IntLiteral")]),s._v("、"),e("code",[s._v("Id")]),s._v("或左括号，就选择表达式语句；而如果是"),e("code",[s._v("Return")]),s._v("，则肯定是选择"),e("code",[s._v("return")]),s._v("语句。")]),s._v(" "),e("p",[s._v("需要使用"),e("code",[s._v("LL")]),s._v("算法，计算"),e("code",[s._v("Token")]),s._v("与产生式选择的关系。")]),s._v(" "),e("h2",{attrs:{id:"ll-算法-计算-first-和-follow-集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ll-算法-计算-first-和-follow-集合"}},[s._v("#")]),s._v(" LL 算法：计算 First 和 Follow 集合")]),s._v(" "),e("p",[e("strong",[s._v("First 集合是每个产生式开头可能会出现的 Token 的集合。")])]),s._v(" "),e("p",[e("img",{attrs:{src:t(426),alt:"First"}})]),s._v(" "),e("p",[e("strong",[s._v("对于某个非终结符后面可能跟着的 Token 的集合，我们叫做 Follow 集合。")])]),s._v(" "),e("p",[s._v("如果预读到的"),e("code",[s._v("Token")]),s._v("在"),e("code",[s._v("Follow")]),s._v("中，那么我们就可以判断当前正在匹配的这个非终结符，产生了"),e("code",[s._v("ε")]),s._v("。")]),s._v(" "),e("p",[s._v("这样在计算了"),e("code",[s._v("First")]),s._v("和"),e("code",[s._v("Follow")]),s._v("集合之后，你就可以通过预读一个"),e("code",[s._v("Token")]),s._v("，来完全确定采用哪个产生式。这种算法叫做"),e("strong",[s._v("LL(1) 算法")]),s._v("。")]),s._v(" "),e("h2",{attrs:{id:"lr-算法-移进和规约"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#lr-算法-移进和规约"}},[s._v("#")]),s._v(" LR 算法：移进和规约")]),s._v(" "),e("p",[s._v("自顶向下算法，是从根节点逐层往下分解，形成最后的"),e("code",[s._v("AST")]),s._v("；而"),e("code",[s._v("LR")]),s._v("算法的原理，则是从底下先拼凑出"),e("code",[s._v("AST")]),s._v("的一些局部拼图，并逐步组装成一棵完整的"),e("code",[s._v("AST")]),s._v("。")]),s._v(" "),e("div",{staticClass:"language-text line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("start -> add\nadd -> add + mul | mul\nmul -> mul * pri | pri\npri -> Int | ( add )\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("如果解析"),e("code",[s._v("2 + 3 * 5")]),s._v("，最终会形成下面的"),e("code",[s._v("AST")]),s._v("：")]),s._v(" "),e("p",[e("img",{attrs:{src:t(427),alt:"AST"}})]),s._v(" "),e("p",[s._v("在下图中，竖线的左边是栈，右边是预读到的一个"),e("code",[s._v("Token")]),s._v("。在做语法解析的过程中，竖线会不断地往右移动，"),e("code",[s._v("Token")]),s._v("入栈，这个过程叫做"),e("strong",[s._v("移进")]),s._v("。")]),s._v(" "),e("p",[e("img",{attrs:{src:t(428),alt:"移进"}})]),s._v(" "),e("p",[s._v("根据栈中的"),e("code",[s._v("Token")]),s._v("数据，通过产生式按推导过程将终结符反推回去，这个还原过程叫"),e("strong",[s._v("规约")]),s._v("。")]),s._v(" "),e("p",[e("img",{attrs:{src:t(429),alt:"规约"}})]),s._v(" "),e("p",[s._v("最后，整个"),e("code",[s._v("AST")]),s._v("构造完毕，而工作区里也就只剩了一个"),e("code",[s._v("Start")]),s._v("节点。")]),s._v(" "),e("p",[e("img",{attrs:{src:t(430),alt:"AST"}})]),s._v(" "),e("p",[s._v("相对于"),e("code",[s._v("LL")]),s._v("算法，"),e("code",[s._v("LR")]),s._v("算法的优点是能够处理左递归文法。但缺点是不利于输出全面的编译错误信息。因为在没有解析完毕之前，算法并不知道最后的"),e("code",[s._v("AST")]),s._v("是什么样子，所以也不清楚当前的语法错误在整体"),e("code",[s._v("AST")]),s._v("中的位置。")])])}),[],!1,null,null,null);a.default=n.exports}}]);